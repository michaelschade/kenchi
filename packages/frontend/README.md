# Kenchi architecture

For an overview of our Architecture, see the diagrams in `docs/`.

# Data: our database, schema, GraphQL, and types

Backend and Frontend both need to know our schema for querying, mutating data, and type checking. Everything starts with backend, so take a look at `backend/README.md` for a rundown on how our data is architected.

Some key GraphQL terminology:

* Query: retrieving data from the backend
* Mutation: a type of query that tells the backend to create or modify data
* Fragment: a fragment describes a reusable or singular structure of data. You'll often find fragments for each object; for example, `WorkflowFragment` describes a Workflow.
* Model: we increasingly autogenerate everything from the backend and `gql` queries, which are represented by Fragments; however, you may also see us create explicit types to describe the data model. For example, `ToolModel` or `WorkflowModel` (although they primarily are just an alias for the underlying fragment, sans any additional granular type annotations like configuration).

The main files you'll see are:

* `backend/api.graphql`: this file is autogenerated by Nexus and describes type signatures for all objects, queries, and mutations
* `frontend/src/graphql/fragments.ts`: this manually created file describes types for commonly reused or intricate pieces of data; for example, a `CollectionFragment` used by both Tools and Workflows
* `frontend/src/graphql/generated.ts`: generated by `pnpm generate:graphql`, these type signatures are inferred from all `gql` queries on the frontend. See this [example on how to use them](https://github.com/kenchi/kenchi/commit/a323f057b34e75f15754ead51609d2dbcba0ad0b).

You may also see some legacy `types.ts` files such as `frontend/src/components/Tool/types.ts` type. These files type the more intricate objects. Where possible, avoid declaring specific types in frontend and instead autogenerate via well-written schema and GraphQL queries.

## Changing the database schema; e.g. exposing a new schema or changing how we update objects

After updating the appropriate backend files (see `backend/README.md`), you should automatically see updates to `backend/api.graphql` (assuming you're running `pnpm start`).

Then, once you've written your GraphQL queries (`gql`) on frontend, regenerate the GraphQL types:

    pnpm generate

This will update the file at `src/graphql/generated.ts` to include your new query/mutation/fragment types. You can import this file and use it as part of your query to get proper types in your code. For example:

```ts
// ...
import { FooQuery } from '../graphql/generated.ts';

gql`
  query FooQuery {
    ...
  }
`

export default function() {
  const { data } = useQuery<FooQuery>();

  // Now data will have a proper type
}
```

# Local development

After initial setup (see top-level README), run:

    pnpm start

## Editor

<!-- TODO(kevin): move this section to the root README once we have prettier everywhere -->

### VSCode

We recommend VSCode with all the recommended extensions installed (you'll be prompted about this when you open the kenchi repo in VSCode). These extensions will enable things like linting, auto-formatting on save, etc.

### VIM

You're on your own, bud.

<!-- TODO(michael): fill this in after testing ale for auto formatting -->

## Available scripts

In the project directory, you can run:

### `pnpm start`

Runs the app in the development mode.<br />
While you *could* open [http://localhost:3000](http://localhost:3000) to view it in the browser, don't. The dev environment is meant to be proxied through https://app.kenchi.dev to better emulate the host structure of prod.

The page will reload if you make edits.<br />
You will also see any lint errors in the console.

### `pnpm test`

Launches the test runner in the interactive watch mode.<br />
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `pnpm build`

Builds the app for production to the `build` folder.<br />
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.<br />
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.
